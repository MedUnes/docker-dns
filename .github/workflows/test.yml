name: Test Pipeline

on: [ push, pull_request ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Run Unit Tests
        run: go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...

  integration-tests:
    needs: unit-tests
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:dind
        options: --privileged
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Start Docker
        run: |
          docker version
          docker run -d --name test-nginx nginx:alpine

      - name: Run Integration Tests
        run: go run gotest.tools/gotestsum@latest --format=testdox -- -tags=integration -v

  debian-install-test:
    runs-on: ubuntu-latest # Use a standard GitHub Actions runner
    env:
      # Define the OS image and container name as environment variables for easy configuration
      TEST_OS_IMAGE: "ubuntu:22.04" # Or "debian:bullseye", "ubuntu:24.04", etc.
      CONTAINER_NAME: "systemd-test-env"

    # Use a container that has Podman pre-installed as the job execution environment.
    # Requires privileged mode on the host runner to allow the inner container
    # full capabilities for systemd and Docker daemon operation.
    container:
      image: quay.io/podman/stable # Official Podman image
      options: --privileged

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Checkout the repository code

# Add this step for debugging path issues
      - name: Verify Workspace Path
        run: |
          echo "Workspace environment variable: ${{ github.workspace }}"
          echo "Listing contents of workspace parent: /home/runner/work/docker-dns"
          ls -la /home/runner/work/docker-dns || echo "Parent directory listing failed."
          echo "---"
          echo "Checking workspace directory existence: ${{ github.workspace }}"
          if [ -d "${{ github.workspace }}" ]; then
            echo "Workspace directory exists. Listing contents:"
            ls -la ${{ github.workspace }}
          else
            echo "ERROR: Workspace directory ${{ github.workspace }} not found!"
            exit 1 # Fail the job if the workspace isn't found
          fi
          echo "---"

      - name: Start systemd container in background
        run: |
          echo "Starting systemd container (${{ env.TEST_OS_IMAGE }}) named ${{ env.CONTAINER_NAME }}..."
          # Use the GHA variable ${{ github.workspace }} directly for the volume mount source.
          podman run -d --name ${{ env.CONTAINER_NAME }} --privileged --cgroupns=host \
            -v ${{ github.workspace }}:/workdir \
            ${{ env.TEST_OS_IMAGE }} /sbin/init

          echo "Waiting for systemd to initialize..."
          # Wait briefly for systemd to start essential services before proceeding.
          # A more robust check would be to loop 'podman exec systemctl is-system-running --wait'
          # but requires handling potential initial "starting" or "degraded" states.
          sleep 15
          # Use -- KEEPINFRALOGGING=true as seen in docker.io/library/ubuntu:22.04 metadata or just try to wait a bit and check if systemctl is runing and working
          # systemctl check
          # podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running --wait || echo "Systemd might be degraded but continuing..."
          # Check if systemd is minimally operational by running a simple systemctl command
          # If this fails, the container likely didn't initialize systemd correctly.
          if podman exec ${{ env.CONTAINER_NAME }} systemctl list-units > /dev/null; then
             echo "Systemd seems operational. Checking system running state..."
             # now wait for the system state (it might take a few seconds)
             if podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running --wait; then
               echo "Systemd reports system is running."
             else
               status=$(podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running)
               echo "Warning: Systemd might be degraded but continuing... State: $status"
               # Optional: Dump logs if degraded
               # podman exec ${{ env.CONTAINER_NAME }} journalctl -n 50 --no-pager
             fi
          else
             echo "Error: Failed to execute systemctl inside the container. Systemd likely failed to start."
             # Dump container logs for debugging
             podman logs ${{ env.CONTAINER_NAME }}
             exit 1
          fi
      - name: Install dependencies (Docker, Docker Compose) inside the container
        run: |
          echo "Updating apt cache and installing dependencies..."
          # Use podman exec to run commands inside the systemd container.
          # Use bash -c '...' to easily run multiple commands.
          # DEBIAN_FRONTEND=noninteractive prevents interactive prompts during installation.
          podman exec ${{ env.CONTAINER_NAME }} bash -c ' \
            export DEBIAN_FRONTEND=noninteractive && \
            apt-get update && \
            apt-get install -y --no-install-recommends \
              docker.io \
              docker-compose-v2 \
              curl \
              git \
              ca-certificates \
              sudo && \
            apt-get clean && rm -rf /var/lib/apt/lists/*'
          echo "Dependencies installed."

      - name: Enable and Start Docker service via systemd
        run: |
          echo "Enabling and starting Docker service using systemctl..."
          podman exec ${{ env.CONTAINER_NAME }} systemctl enable docker
          podman exec ${{ env.CONTAINER_NAME }} systemctl start docker

          echo "Waiting for Docker service to become active..."
          # Loop until 'docker.service' is active or timeout (e.g., 30 seconds)
          timeout=30
          interval=2
          elapsed=0
          while ! podman exec ${{ env.CONTAINER_NAME }} systemctl is-active --quiet docker; do
            if [ $elapsed -ge $timeout ]; then
              echo "Timeout waiting for Docker service to start."
              podman exec ${{ env.CONTAINER_NAME }} systemctl status docker
              podman exec ${{ env.CONTAINER_NAME }} journalctl -u docker --no-pager -n 50
              exit 1
            fi
            echo "Waiting for Docker... (${elapsed}s / ${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Docker service is active."
          podman exec ${{ env.CONTAINER_NAME }} docker info # Verify docker is running

      - name: Run Application/Package Tests
        run: |
          echo "Running tests inside the container..."
          podman exec ${{ env.CONTAINER_NAME }} docker ps
          podman exec ${{ env.CONTAINER_NAME }} docker run --rm hello-world
          podman exec ${{ env.CONTAINER_NAME }} echo "Environment ready for testing."

      - name: Cleanup systemd container
        # Use always() to ensure cleanup runs even if previous steps fail
        if: always()
        run: |
          echo "Stopping and removing the test container..."
          podman stop ${{ env.CONTAINER_NAME }} || echo "Failed to stop container (may already be stopped)"
          podman rm ${{ env.CONTAINER_NAME }} || echo "Failed to remove container (may already be removed)"
          echo "Cleanup complete."
