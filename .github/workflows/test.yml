name: Test Pipeline

on: [ push, pull_request ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Run Unit Tests
        run: go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...

  integration-tests:
    needs: unit-tests
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:dind
        options: --privileged
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Start Docker
        run: |
          docker version
          docker run -d --name test-nginx nginx:alpine

      - name: Run Integration Tests
        run: go run gotest.tools/gotestsum@latest --format=testdox -- -tags=integration -v

  debian-install-test:
    runs-on: ubuntu-latest # Use a standard GitHub Actions runner
    env:
      # Define the OS image and container name as environment variables for easy configuration
      TEST_OS_IMAGE: "ubuntu:22.04" # Or "debian:bullseye", "ubuntu:24.04", etc.
      CONTAINER_NAME: "systemd-test-env"

    # Use a container that has Podman pre-installed as the job execution environment.
    # Requires privileged mode on the host runner to allow the inner container
    # full capabilities for systemd and Docker daemon operation.
    container:
      image: quay.io/podman/stable # Official Podman image
      options: --privileged

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Checkout the repository code

      - name: Start systemd container in background
        run: |
          echo "Starting systemd container (${{ env.TEST_OS_IMAGE }}) named ${{ env.CONTAINER_NAME }}..."
          # Run the inner container:
          # -d: detached (background)
          # --name: assign a predictable name
          # --privileged: Essential for systemd and nested Docker daemon functionality inside the container.
          #               It grants the container extended privileges on the host system.
          # -v: Mount the current directory (containing checked-out code) to /workdir inside the container.
          # --cgroupns=host: Ensures cgroup namespace compatibility, often helpful for systemd.
          # The command '/sbin/init' starts systemd as PID 1 inside the container.
          podman run -d --name ${{ env.CONTAINER_NAME }} --privileged --cgroupns=host \
            -v ${{ github.workspace }}:/workdir \
            ${{ env.TEST_OS_IMAGE }} /sbin/init

          echo "Waiting for systemd to initialize..."
          # Wait briefly for systemd to start essential services before proceeding.
          # A more robust check would be to loop 'podman exec systemctl is-system-running --wait'
          # but requires handling potential initial "starting" or "degraded" states.
          sleep 15
          podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running --wait || echo "Systemd might be degraded but continuing..."

      - name: Install dependencies (Docker, Docker Compose) inside the container
        run: |
          echo "Updating apt cache and installing dependencies..."
          # Use podman exec to run commands inside the systemd container.
          # Use bash -c '...' to easily run multiple commands.
          # DEBIAN_FRONTEND=noninteractive prevents interactive prompts during installation.
          podman exec ${{ env.CONTAINER_NAME }} bash -c ' \
            export DEBIAN_FRONTEND=noninteractive && \
            apt-get update && \
            apt-get install -y --no-install-recommends \
              docker.io \
              docker-compose-v2 \
              curl \
              git \
              ca-certificates \
              sudo && \
            apt-get clean && rm -rf /var/lib/apt/lists/*'
          echo "Dependencies installed."

      - name: Enable and Start Docker service via systemd
        run: |
          echo "Enabling and starting Docker service using systemctl..."
          podman exec ${{ env.CONTAINER_NAME }} systemctl enable docker
          podman exec ${{ env.CONTAINER_NAME }} systemctl start docker

          echo "Waiting for Docker service to become active..."
          # Loop until 'docker.service' is active or timeout (e.g., 30 seconds)
          timeout=30
          interval=2
          elapsed=0
          while ! podman exec ${{ env.CONTAINER_NAME }} systemctl is-active --quiet docker; do
            if [ $elapsed -ge $timeout ]; then
              echo "Timeout waiting for Docker service to start."
              podman exec ${{ env.CONTAINER_NAME }} systemctl status docker
              podman exec ${{ env.CONTAINER_NAME }} journalctl -u docker --no-pager -n 50
              exit 1
            fi
            echo "Waiting for Docker... (${elapsed}s / ${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Docker service is active."
          podman exec ${{ env.CONTAINER_NAME }} docker info # Verify docker is running

      - name: Run Application/Package Tests
        run: |
          echo "Running tests inside the container..."
          # Example: Run a test script from your repository
          # podman exec ${{ env.CONTAINER_NAME }} /workdir/run-my-tests.sh

          # Example: Directly execute test commands
          # Verify Debian package installation and service status
          # podman exec ${{ env.CONTAINER_NAME }} apt-get install -y /workdir/path/to/your-package.deb
          # podman exec ${{ env.CONTAINER_NAME }} systemctl status your-service
          # podman exec ${{ env.CONTAINER_NAME }} your-application --version

          # Example: Verify Docker and Docker Compose are working
          podman exec ${{ env.CONTAINER_NAME }} docker ps
          podman exec ${{ env.CONTAINER_NAME }} docker run --rm hello-world
          # Assuming you have a docker-compose.yml in /workdir
          # podman exec -w /workdir ${{ env.CONTAINER_NAME }} docker compose up -d
          # podman exec -w /workdir ${{ env.CONTAINER_NAME }} docker compose ps

          # Placeholder for actual tests:
          echo "Test placeholder: Simulating successful test execution."
          podman exec ${{ env.CONTAINER_NAME }} echo "Environment ready for testing."

      - name: Cleanup systemd container
        # Use always() to ensure cleanup runs even if previous steps fail
        if: always()
        run: |
          echo "Stopping and removing the test container..."
          podman stop ${{ env.CONTAINER_NAME }} || echo "Failed to stop container (may already be stopped)"
          podman rm ${{ env.CONTAINER_NAME }} || echo "Failed to remove container (may already be removed)"
          echo "Cleanup complete."
