name: Test Pipeline

on: [ push, pull_request ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Run Unit Tests
        run: go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...

  integration-tests:
    needs: unit-tests
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:dind
        options: --privileged
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21

      - name: Start Docker
        run: |
          docker version
          docker run -d --name test-nginx nginx:alpine

      - name: Run Integration Tests
        run: go run gotest.tools/gotestsum@latest --format=testdox -- -tags=integration -v

  debian-install-test:
    runs-on: ubuntu-latest # Use a standard GitHub Actions runner
    env:
      # Define the OS image and container name as environment variables for easy configuration
      TEST_OS_IMAGE: "ubuntu:22.04" # Or "debian:bullseye", "ubuntu:24.04", etc.
      CONTAINER_NAME: "systemd-test-env"

    # Use a container that has Podman pre-installed as the job execution environment.
    # Requires privileged mode on the host runner to allow the inner container
    # full capabilities for systemd and Docker daemon operation.
    container:
      image: quay.io/podman/stable # Official Podman image
      options: --privileged

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Checkout the repository code

# actions/checkout needs to run first to populate the workspace

      - name: Verify Workspace Path (inside job container)
        # This step now checks the correct path within the job container
        run: |
          echo "Host workspace path variable: ${{ github.workspace }}"
          echo "Expected path inside JOB CONTAINER: /github/workspace"
          echo "---"
          echo "Checking workspace directory existence inside job container: /github/workspace"
          # Check the standard mount point for the workspace inside a job container
          if [ -d "/github/workspace" ]; then
            echo "Job container workspace directory '/github/workspace' exists. Listing contents:"
            ls -la /github/workspace
          else
            echo "ERROR: Workspace directory /github/workspace not found inside job container!"
            # Also check GITHUB_WORKSPACE env var *inside* the container if it exists
            echo "(Env var GITHUB_WORKSPACE inside container is: $GITHUB_WORKSPACE)" # Might still be the host path or unset
            exit 1 # Fail the job if the workspace isn't found
          fi
          echo "---"

      - name: Start systemd container in background
        run: |
          echo "Starting systemd container (${{ env.TEST_OS_IMAGE }}) named ${{ env.CONTAINER_NAME }}..."
          # --- CORRECTED PATH ---
          # Use the standard job container workspace path /github/workspace as the source for the volume mount.
          # This mounts the code from the job container into the inner systemd container at /workdir.
          podman run -d --name ${{ env.CONTAINER_NAME }} --privileged --cgroupns=host \
            -v /github/workspace:/workdir \
            ${{ env.TEST_OS_IMAGE }} /sbin/init

          echo "Waiting for systemd to initialize..."
          sleep 15 # Simple wait

          # Check if systemd is minimally operational
          if podman exec ${{ env.CONTAINER_NAME }} systemctl list-units > /dev/null; then
             echo "Systemd seems operational. Checking system running state..."
             # Wait for the system to reach the 'running' state
             if podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running --wait; then
               echo "Systemd reports system is running."
             else
               status=$(podman exec ${{ env.CONTAINER_NAME }} systemctl is-system-running)
               echo "Warning: Systemd might be degraded but continuing... State: $status"
               # Optional: Dump logs if degraded for debugging
               # podman exec ${{ env.CONTAINER_NAME }} journalctl -n 50 --no-pager
             fi
          else
             echo "Error: Failed to execute systemctl inside the container. Systemd likely failed to start."
             # Dump container logs for debugging systemd startup issues
             podman logs ${{ env.CONTAINER_NAME }}
             exit 1
          fi    
      - name: Install dependencies (Docker, Docker Compose) inside the container
        run: |
          echo "Updating apt cache and installing dependencies..."
          # Use podman exec to run commands inside the systemd container.
          # Use bash -c '...' to easily run multiple commands.
          # DEBIAN_FRONTEND=noninteractive prevents interactive prompts during installation.
          podman exec ${{ env.CONTAINER_NAME }} bash -c ' \
            export DEBIAN_FRONTEND=noninteractive && \
            apt-get update && \
            apt-get install -y --no-install-recommends \
              docker.io \
              docker-compose-v2 \
              curl \
              git \
              ca-certificates \
              sudo && \
            apt-get clean && rm -rf /var/lib/apt/lists/*'
          echo "Dependencies installed."

      - name: Enable and Start Docker service via systemd
        run: |
          echo "Enabling and starting Docker service using systemctl..."
          podman exec ${{ env.CONTAINER_NAME }} systemctl enable docker
          podman exec ${{ env.CONTAINER_NAME }} systemctl start docker

          echo "Waiting for Docker service to become active..."
          # Loop until 'docker.service' is active or timeout (e.g., 30 seconds)
          timeout=30
          interval=2
          elapsed=0
          while ! podman exec ${{ env.CONTAINER_NAME }} systemctl is-active --quiet docker; do
            if [ $elapsed -ge $timeout ]; then
              echo "Timeout waiting for Docker service to start."
              podman exec ${{ env.CONTAINER_NAME }} systemctl status docker
              podman exec ${{ env.CONTAINER_NAME }} journalctl -u docker --no-pager -n 50
              exit 1
            fi
            echo "Waiting for Docker... (${elapsed}s / ${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Docker service is active."
          podman exec ${{ env.CONTAINER_NAME }} docker info # Verify docker is running

      - name: Run Application/Package Tests
        run: |
          echo "Running tests inside the container..."
          podman exec ${{ env.CONTAINER_NAME }} docker ps
          podman exec ${{ env.CONTAINER_NAME }} docker run --rm hello-world
          podman exec ${{ env.CONTAINER_NAME }} echo "Environment ready for testing."

      - name: Cleanup systemd container
        # Use always() to ensure cleanup runs even if previous steps fail
        if: always()
        run: |
          echo "Stopping and removing the test container..."
          podman stop ${{ env.CONTAINER_NAME }} || echo "Failed to stop container (may already be stopped)"
          podman rm ${{ env.CONTAINER_NAME }} || echo "Failed to remove container (may already be removed)"
          echo "Cleanup complete."
